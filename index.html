<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="PRACTICAL MACHINE LEARNING : Practical Machine Learning project for Coursera">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Pml-coursera </title>
    
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mauriciogtec/PML-Coursera">View on GitHub</a>

          <h1 id="project_title">PRACTICAL MACHINE LEARNING IN COURSERA</h1>
          <h2 id="project_tagline">Week 3 project using Random Forests</h2>
          <h2 id="project_tagline">by Mauricio G. Tec </h2>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>

<title>PRACTICAL MACHINE LEARNING</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}
tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; font-size: 11px;
}
h1 { 
   font-size:2.2em; 
}
h2 { 
   font-size:1.8em; 
}
h3 { 
   font-size:1.4em; 
}
h4 { 
   font-size:1.0em; 
}
h5 { 
   font-size:0.9em; 
}
h6 { 
   font-size:0.8em; 
}
a:visited {
   color: rgb(50%, 0%, 50%);
}
pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}
pre code {
   display: block; padding: 0.5em;
}
code.r, code.cpp {
   background-color: #F8F8F8;
}
table, td, th {
  border: none;
}
blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}
hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}
@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }
   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }
   hr { 
      visibility: hidden;
      page-break-before: always;
   }
   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }
   tr, img { 
      page-break-inside: avoid; 
   }
   img { 
      max-width: 100% !important; 
   }
   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }
   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }
   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }
   pre .literal {
     color: rgb(88, 72, 246)
   }
   pre .number {
     color: rgb(0, 0, 205);
   }
   pre .comment {
     color: rgb(76, 136, 107);
   }
   pre .keyword {
     color: rgb(0, 0, 255);
   }
   pre .identifier {
     color: rgb(0, 0, 0);
   }
   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>



<p>This project is a demostration of the prediction algorithm know as <em>Random Forests</em>. The ideas of this method are (1) to create various decision trees sampling both from the set of observations and from the set of variables and (2) to average the prediction probabilities of each tree given a new observation not in the original dataset. </p>

<p>This project is part of the course &ldquo;Practical Machine Learing&rdquo; in the Coursera Specialization in Data Science by the John Hopkins University. All the impliementation is done using the <em>caret</em> package in R as demonstrated in the course. </p>

<h3>Description of the data:</h3>

<p><em>Note</em> : this excerpt is taken directly from the description of the assignment in the course page.</p>

<p>Using devices such as Jawbone Up, Nike FuelBand, and Fitbit it is now possible to collect a large amount of data about personal activity relatively inexpensively. These type of devices are part of the quantified self movement of a group of enthusiasts who take measurements about themselves regularly to improve their health, to find patterns in their behavior, or because they are tech geeks. One thing that people regularly do is quantify how much of a particular activity they do, but they rarely quantify how well they do it. In this project, the goal will be to use data from accelerometers on the belt, forearm, arm, and dumbell of 6 participants. They were asked to perform barbell lifts correctly and incorrectly in 5 different ways. More information is available from the website here: <a href="http://groupware.les.inf.puc-rio.br/har">http://groupware.les.inf.puc-rio.br/har</a>.</p>

<h3>Project outline:</h3>

<ol>
<li><p>Since we do not know what is thea real class of the observations in the testing set that has been provided, in order to demonstrate the technique, we first split the training set in a training subset and in a testing set. Furthermore, the training subset is reduced to 100 observations, since the <em>Random Forests</em> demands a lot of computation power and time. We show (a) a predicting table comparing the predictions and real resuls in the testing set, (b) a sample tree and &copy; two graphs chosen showing comparisons between predictors and accuracy in prediction.</p></li>
<li><p>We now implement the full model with cross validation. We have decided to use 10-fold **cross validation**, although only three repetitions were used for computational reasons. Furthermore, the total number of observations in the training set had to be reduced to 2000 observations. We need the cross-validation because otherwise we may be overfitting our data. In the two runs below one sees how the error (accuracy) decreases significantly when more observations are included, even under cross-validation. In principle, cross-validation reduces the accuracy since it gives a better estimate of the erros accounting for overfitting problems.  </p></li>
</ol>

<h2>1) Demonstration implementation with fewer observations and splitting of the training set</h2>

<p>First we load the necessary packages and data in R</p>

<pre><code class="r">library(caret)
library(ggplot2)
library(gridExtra)

set.seed(110104)

training &lt;- read.csv(&quot;pml-training.csv&quot;)[ ,-1]
# remove   columns with NA&#39;s or empty values
training &lt;- training[ ,!sapply(training, function(x) 
  any(is.na(x) | (x==&quot;&quot;)))] 
testing &lt;- read.csv(&quot;pml-testing.csv&quot;)[ ,-1]
# matching the variables in testing and training sets
vars &lt;- names(training) 
testing &lt;- testing[ ,names(testing) %in% vars]
</code></pre>

<p>Now, we will split the trianing set in subsets for training and testing in the first part of our project. We also use the function sample to take a subset of size 100.</p>

<pre><code class="r">inTraining &lt;- createDataPartition(training$classe, p = .6, list = FALSE)
training.sub &lt;- training[inTraining, ]
testing.sub &lt;- training[-inTraining, ]
# For demonstration purposes we only use 250 observations
training.sub &lt;- training.sub[sample(dim(training.sub)[1], 100), ]
</code></pre>

<p>The following command fits the model using random forests.</p>

<pre><code class="r">modFit.dem &lt;- train(classe ~., data=training.sub, method=&quot;rf&quot;)
modFit.dem
</code></pre>

<pre><code>## Random Forest 
## 
## 100 samples
##  58 predictor
##   5 classes: &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## 
## Summary of sample sizes: 100, 100, 100, 100, 100, 100, ... 
## 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy  Kappa   Accuracy SD  Kappa SD
##    2    0.5061    0.3598  0.08715      0.10559 
##   41    0.4857    0.3435  0.08349      0.09601 
##   80    0.4736    0.3266  0.08386      0.09867 
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 2.
</code></pre>

<p>We know compare the predicted results agains the real results in the testing subset created earlier (not in the final testing subset of 20 individuals of which we do not know the real value, but in the one separated from the original training set).</p>

<pre><code class="r">pred &lt;- predict(modFit.dem, testing.sub)
testingTRUE &lt;- testing.sub$classe
predRight &lt;- pred==testingTRUE
table(pred, testingTRUE)
</code></pre>

<pre><code>##     testingTRUE
## pred    A    B    C    D    E
##    A 2101  548  694  314  157
##    B   11  758   38   20  134
##    C   31   80  443   54   14
##    D   28   35   87  637   58
##    E   61   97  106  261 1079
</code></pre>

<p>Here we see an example of a tree</p>

<pre><code class="r">tree &lt;- getTree(modFit.dem$finalModel, k=3, labelVar=TRUE)
tree
</code></pre>

<pre><code>
##	left_daughter	right_daughter	split_var	split_point	status prediction
##	1	2	3	gyros_belt_y	1.35E-01	1	&lt;NA&gt;
##	2	4	5	num_window	6.87E+02	1	&lt;NA&gt;
##	3	0	0	&lt;NA&gt;	0.00E+00	-1	E
##	4	6	7	roll_forearm	1.35E+02	1	&lt;NA&gt;
##	5	8	9	roll_belt	1.16E+02	1	&lt;NA&gt;
##	6	10	11	gyros_arm_x	-4.00E-02	1	&lt;NA&gt;
##	7	12	13	cvtd_timestamp05/12/2011	14:24	1	&lt;NA&gt;
##	8	14	15	accel_dumbbell_x	-8.00E+01	1	&lt;NA&gt;
##	9	0	0	&lt;NA&gt;	0.00E+00	-1	C
##	10	16	17	magnet_arm_y	2.39E+02	1	&lt;NA&gt;
##	11	18	19	accel_belt_z	-2.04E+02	1	&lt;NA&gt;
##	12	20	21	magnet_belt_x	4.90E+01	1	&lt;NA&gt;
##	13	0	0	&lt;NA&gt;	0.00E+00	-1	D
##	14	0	0	&lt;NA&gt;	0.00E+00	-1	A
##	15	0	0	&lt;NA&gt;	0.00E+00	-1	B
##	16	22	23	yaw_forearm	-1.00E+02	1	&lt;NA&gt;
##	17	24	25	magnet_dumbbell_y	2.30E+02	1	&lt;NA&gt;
##	18	0	0	&lt;NA&gt;	0.00E+00	-1	E
##	19	26	27	new_windowyes	5.00E-01	1	&lt;NA&gt;
##	20	28	29	magnet_dumbbell_y	4.23E+02	1	&lt;NA&gt;
##	21	0	0	&lt;NA&gt;	0.00E+00	-1	A
##	22	0	0	&lt;NA&gt;	0.00E+00	-1	D
##	23	30	31	gyros_forearm_y	1.13E+00	1	&lt;NA&gt;
##	24	0	0	&lt;NA&gt;	0.00E+00	-1	C
##	25	0	0	&lt;NA&gt;	0.00E+00	-1	D
##	26	32	33	gyros_arm_x	3.55E-01	1	&lt;NA&gt;
##	27	0	0	&lt;NA&gt;	0.00E+00	-1	A
##	28	34	35	yaw_forearm	-2.51E+01	1	&lt;NA&gt;
##	29	0	0	&lt;NA&gt;	0.00E+00	-1	D
##	30	36	37	accel_forearm_x	-1.27E+02	1	&lt;NA&gt;
##	31	0	0	&lt;NA&gt;	0.00E+00	-1	B
##	32	0	0	&lt;NA&gt;	0.00E+00	-1	A
##	33	38	39	magnet_dumbbell_z	5.25E+01	1	&lt;NA&gt;
##	34	40	41	magnet_arm_z	-3.63E+02	1	&lt;NA&gt;
##	35	0	0	&lt;NA&gt;	0.00E+00	-1	E
##	36	0	0	&lt;NA&gt;	0.00E+00	-1	A
##	37	0	0	&lt;NA&gt;	0.00E+00	-1	E
##	38	42	43	gyros_belt_z	-5.00E-02	1	&lt;NA&gt;
##	39	44	45	raw_timestamp_part_1	1.32E+09	1	&lt;NA&gt;
##	40	0	0	&lt;NA&gt;	0.00E+00	-1	D
##	41	0	0	&lt;NA&gt;	0.00E+00	-1	E
##	42	0	0	&lt;NA&gt;	0.00E+00	-1	A
##	43	46	47	gyros_arm_y	-8.55E-01	1	&lt;NA&gt;
##	44	0	0	&lt;NA&gt;	0.00E+00	-1	B
##	45	0	0	&lt;NA&gt;	0.00E+00	-1	D
##	46	0	0	&lt;NA&gt;	0.00E+00	-1	B
##	47	48	49	gyros_belt_z	2.10E-01	1	&lt;NA&gt;
##	48	0	0	&lt;NA&gt;	0.00E+00	-1	D
##	49	0	0	&lt;NA&gt;	0.00E+00	-1	E

</code></pre>

<p>Here we see an example of comparing predictors with accuracy of predictions. The predictos are taken in order of appearance as nods in the previously extracted tree.</p>

<pre><code class="r">classvars &lt;- na.omit(as.character(tree[ ,&quot;split var&quot;]))[1:4]
classvars
</code></pre>

<pre><code>## [1] &quot;gyros_belt_y&quot; &quot;num_window&quot;   &quot;roll_forearm&quot; &quot;roll_belt&quot;
</code></pre>

<pre><code class="r">q1 &lt;- qplot(testing.sub[ ,classvars[1]], testing.sub[ ,classvars[2]], data=testing.sub, main=&quot;new data predictions&quot;, xlab=classvars[1], ylab=classvars[2], colour=predRight)
q2 &lt;- qplot(testing.sub[ ,classvars[3]], testing.sub[ ,classvars[4]], data=testing.sub, main=&quot;new data predictions&quot;, xlab=classvars[3], ylab=classvars[4], colour=predRight)
grid.arrange(q1, q2, ncol=2)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-7"/> </p>

<h2>Full model with cross-validation and final prediction</h2>

<p>For our full model we set-up the fit controls to use 10-fold cross validation with three repetitions. </p>

<pre><code class="r">fitControl &lt;- trainControl(## 10-fold CV
                           method = &quot;repeatedcv&quot;,
                           number = 10,
                           ## repeated two times
                           repeats = 3)
</code></pre>

<p>Now we run the model. We can observe that even when restricting to 2000 out of the 19622 available observations it is really slow.</p>

<pre><code class="r">ptm &lt;- proc.time()
modFitFull &lt;- train(classe ~., data=training[sample(dim(training)[1], 2000), ],  trControl = fitControl, method=&quot;rf&quot;, prox=TRUE)
modFitFull
</code></pre>

<pre><code>## Random Forest 
## 
## 2000 samples
##   58 predictor
##    5 classes: &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 3 times) 
## 
## Summary of sample sizes: 1799, 1801, 1798, 1800, 1801, 1801, ... 
## 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy  Kappa   Accuracy SD  Kappa SD
##    2    0.9575    0.9459  0.014750     0.01878 
##   41    0.9845    0.9803  0.008922     0.01135 
##   80    0.9823    0.9775  0.008866     0.01127 
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 41.
</code></pre>

<pre><code class="r">proc.time() - ptm
</code></pre>

<pre><code>##    user  system elapsed 
## 1347.45    8.08 1364.10
</code></pre>

<p>Here is the list of prediction of the 20 individuals in the testing set.</p>

<pre><code class="r">answers &lt;- predict(modFitFull, testing)
answers
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<pre><code class="r">pml_write_files = function(x){
  n = length(x)
  for(i in 1:n){
    filename = paste0(&quot;problem_id_&quot;,i,&quot;.txt&quot;)
    write.table(x[i],file=filename,quote=FALSE,row.names=FALSE,col.names=FALSE)
  }
}
pml_write_files(answers)
</code></pre>

  </body>
</html>
